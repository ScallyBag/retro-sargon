Todo:
CARRET
CCIR
PRTBLK
PRTLIN

p8 = imm8, reg8 or mem8
lhs8 = reg8 or mem8
reg8 = A,B,C,D,E,H,L,M
reg16 = B (->CX), D (->DX), H (->BX)  also X->SI Y->DI

mem8 examples;
MLFLG(X)
MLFRP(X)
MLTOP(X)
MLVAL(X)
MLPTR(X)
MLPTR+1(X)
-8(X)
9(X)
21(X)
91(X)
BOARD(X)
BOARD(Y)
DPOINT(Y)
DCOUNT(Y)
DIRECT(Y)
PVALUE(X)
PLIST(X)
PLISTD(X)

mem16 examples;
MLPTRI
MLPTRJ

Translate:
ADD p8 -> ADD al,p8
ADI p8 -> ADD al,p8
ANA p8 -> AND al,p8
ANI p8 -> AND al,p8
BIT n,reg8 -> MOV ah,reg8; AND ah,mask[n] # but damages other flags
BIT n,mem8 same 
CALL addr -> CALL addr
CC addr -> JNC temp; CALL addr; temp:
CMP reg8  ->  CMD al,reg8
CNZ addr -> JZ temp; CALL addr; temp:
CPI imm8 -> CMP al, imm8
CZ addr -> JNZ temp; CALL addr; temp:
DAD reg16 -> LAHF; ADD bx,reg16; SAHF;
DADX reg16 -> LAHF; ADD si,reg16; SAHF;
DADY reg16 -> LAHF; ADD di,reg16; SAHF;     ## not actually used in codebase
DCR reg8 -> DEC reg8
DCX reg16 -> LAHF; DEC reg16; SAHF;      ## INC DEC reg16; Z80 flags unaffected, X86 INC DEC preserve CY only
DJNZ addr -> LAHF; DEC cl; JNZ addr; SAHF; ## flags affected at addr (sadly not much to be done)
DSBC reg16 -> SBB bx,reg16
EXAF -> macro/call
EXX -> macro/call
INR reg8 -> INC reg8
INX reg16 -> LAHF; INC reg16; SAHF;      ## INC DEC reg16; Z80 flags unaffected, X86 INC DEC preserve CY only
JC addr -> JC addr
JM addr -> JM addr  (jump sign negative)
JMP addr -> JMP addr
JMPR addr -> JMP addr (avoid relative jumps unless we get into mega optimisation)
JNZ addr -> JNZ addr
JP addr -> JP addr  (jump sign positive)
JPE addr -> JPE addr  (jump parity even - check this one, parity bit not 100% compatible) 
JRC addr -> JC addr (avoid relative jumps unless we get into mega optimisation)
JRNC addr -> JNC addr
JRNZ addr -> JNZ addr
JRZ addr -> JZ addr
JZ addr -> JZ addr
LDA mem8 -> MOV AL,mem8
LDAR -> Load A with incrementing R (RAM refresh) register ????
LDAX reg16 -> MOV al,[reg16]
LBCD mem16 -> MOV cx,[mem16]
LDED mem16 -> MOV dx,[mem16]
LHLD mem16 -> MOV bx,[mem16]
LIXD mem16 -> MOV si,[mem16]
LIYD mem16 -> MOV di,[mem16]
LXI reg16, imm16 -> MOV reg16, imm16 (if imm16 is a label precede it with offset)
MOV lhs8, p8 -> MOV lhs8, p8
MVI lhs8, imm8 -> MOV lhs8, imm8
NEG -> NEG al
POP reg16 -> POP reg16
POP PSW -> POP AX; SAHF
PUSH reg16 -> PUSH reg16
PUSH PSW -> LAHF; PUSH AX
RAL -> RCL al,1             # rotate left through CY
RARR reg8 -> RCR reg, 1     # rotate right through CY
RLD -> macro or call; 12 bits of low AL and byte [BX] rotated 4 bits left (!!)
RRD -> macro or call; 12 bits of low AL and byte [BX] rotated 4 bits right (!!)
RES n,reg8 -> LAHF; AND reg8,not mask[n]; SAHF
RET -> RET
RC -> JNC temp; RET; temp:
RNC -> JC temp; RET; temp:
RNZ -> JZ temp; RET; temp:
RZ -> JNZ temp; RET; temp:
SBCD mem16 -> mov [mem16],cx
SDED mem16 -> mov [mem16],dx
SHLD mem16 -> mov [mem16],bx
SIXD mem16 -> mov [mem16],si
SET n,reg8 -> LAHF; OR reg8,mask[n]; SAHF
SLAR reg8 -> SHL reg8,1     # left shift into CY, bit 0 zeroed (arithmetic and logical are the same)
SRAR reg8 -> SAR reg8,1     # arithmetic right shift into CY, bit 7 preserved
SRLR reg8 -> SHR reg8,1     # logical right shift into CY, bit 7 zeroed
STA mem8 -> MOV [mem8],al
SUB al,reg8 -> SUB al,reg8
SUI imm8 -> SUB al,imm8
XCHG -> XCHG BX,DX
XRA reg8 -> XOR al,reg8
XRI imm8 -> XOR al,imm8
